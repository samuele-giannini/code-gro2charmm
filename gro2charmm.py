#!/usr/bin/env python


# Converter: gro2charmm.py
# Copyright (c) 2024 Samuele Giannini <samuele.giannini@cnr.it>
# Released under the GNU Public License 3 (or higher, your choice)
# See the file COPYING for details.


"""Program to convert the topology generated by Joyce (in gromacs format) to Charmm format.
   This program takes the topology *top and generates *pot and *psf file that could be use 
   to run MD in programs like CP2K, NAMD, etc...

   NOTE: The generated psf can be used directly in CP2K specifying "CONN_FILE_FORMAT  UPSF"

   KNOWN ISSUES: 
   - impropers dihedral with harmonic potential (as described in Joyce) do not 
     work in CP2K when the equilibrium angle is 180 deg. This causes a problem with the phase
     of the potential. Same problems with negative values.
   - 1-4 LJ interactions and CHRG scaling must be done by the user within the MD program
"""

import os 
import sys
import numpy as np
import argparse as arg

# import some parsing modules
current_dir = os.path.dirname(os.path.abspath(__file__))
module_dir = os.path.join(current_dir,  'modules')
sys.path.append(module_dir)
from top import *

# Conversion units #
kcal2kj = 4.184
nm2A = 10.0
####################
VERSION  = '1.0.0'
PROGVERS = 'CODE version %s' % (VERSION)

def dreid_imp(psi, k):
    e = k * (1 - np.cos(np.radians(psi)))
    return e

def is_list_present(target_list, list_of_lists):
    target_set = set(tuple(target_list))
    for sublist in list_of_lists:
        sublist_set = set(tuple(sublist))
        if target_set == sublist_set:
            return True
    return False

def _readatoms(t):
    """Read Atoms section from gromacs TOP"""

    fmt_atm_title = "%4s %6s %12s %12s %12s" % ("i", "type", "q", "eps", "sigma")
    fmt_atm = "%4d %6s %12.6f %12.6f %12.6f "
    atms = t.molecules[0].atoms
    print("Atoms")
    print("-----")
    print(fmt_atm_title)

    dict_atom_types = {}
    lj_list = ["NONBONDED"]
    for N, atm in enumerate(atms, start=1):

        # Get atoms
        i = atm.atomtype
        q = atm.charge

        pdict = [ x.gromacs for x in t.atomtypes if x.atype == i ][0]
        # LJ for atom types (charmm format)
        eps = pdict["param"]["lje"] / kcal2kj
        sig = pdict["param"]["ljl"] / 0.17818 # Rmin/2 - factor checked against Parmed
        #eps = pdict["param"]["lje14"] / kcal2kj
        #sig = pdict["param"]["ljl14"] / 0.17818 # Rmin/2 - factor checked against Parmed
        print(fmt_atm % (N, i, q, eps, sig))
        dict_atom_types.update({N : i})
        temp = [str(i),"0.0000", eps, sig]
        if temp not in lj_list:
            lj_list.append(temp)
    return dict_atom_types, lj_list, atms

def _readbonds(t,dict_atom_types):
    """Read Bonds section from gromacs TOP
    bonds and angles are not repeated in the pot file 
    if there is already the corresponding value"""

    fmt_bnd_title = "%4s %4s %12s %6s" % ("i", "j", "K", "r0")
    fmt_bnd = "%4s %4s %12.4f %6.2f ; %4s %4s" 
    bnds = t.molecules[0].bonds
    print("Bonds")
    print("-----")
    print(fmt_bnd_title)
    bnd_list = ["BONDS"]
    for bnd in bnds:
        # Get atoms
        i = int(bnd.atom1.number)
        j = int(bnd.atom2.number)

        kb = (bnd.gromacs["param"]["kb"]/(2*nm2A**2*kcal2kj))
        b0 = bnd.gromacs["param"]["b0"] * nm2A
        #print(fmt_bnd % (str(dict_atom_types[i]), str(dict_atom_types[j]), kb, b0))
        print(fmt_bnd % (str(i), str(j), kb, b0, str(dict_atom_types[i]), str(dict_atom_types[j])))
        #kb = round(kb, 2)
        #b0 = round(b0, 2)
        temp = [str(dict_atom_types[i]), str(dict_atom_types[j]), kb, b0]
        #if temp not in bnd_list:
        if not is_list_present(temp, bnd_list):
            bnd_list.append(temp)
        
    return bnd_list, bnds

def _readangles(t,dict_atom_types):
    """Read Angles section from gromacs TOP
    bonds and angles are not repeated in the pot file 
    if there is already the corresponding value""" 

    fmt_ang_title = "%4s %4s %4s %12s %6s" % ("i", "j", "k", "K", "t0")
    fmt_ang = "%4s %4s %4s %12.4f %6.2f ; %4s %4s %4s "

    angs = t.molecules[0].angles
    print("Angles")
    print("------")
    print(fmt_ang_title)
    ang_list = ["ANGLES"]
    for ang in angs:

        # Get atoms
        i = ang.atom1.number
        j = ang.atom2.number
        k = ang.atom3.number

        kt = ang.gromacs["param"]["ktetha"] / (2*kcal2kj)
        t0 = ang.gromacs["param"]["tetha0"]
        print(fmt_ang % (i, j, k, kt, t0, str(dict_atom_types[i]), str(dict_atom_types[j]), str(dict_atom_types[k])))
        temp = [str(dict_atom_types[i]), str(dict_atom_types[j]), str(dict_atom_types[k]), kt, t0]
        #if temp not in ang_list:
        if not is_list_present(temp, ang_list):
           ang_list.append(temp)
    return ang_list, angs

def _readdihed(t,dict_atom_types):
    fmt_dihed_title = "%4s %4s %4s %4s %12s %6s %3s" % ("i", "j", "k", "l", "K", "delta", "n")
    fmt_dihed = "%4s %4s %4s %4s %12.4f %6.2f %3d ; %4s %4s %4s %4s"

    dihs = t.molecules[0].dihedrals
    print("Dihedrals")
    print("---------")
    print(fmt_dihed_title)
    dih_list = ["DIHEDRALS"]
    dih_num = []
    for dih in dihs:

        # Get atoms
        i = dih.atom1.number
        j = dih.atom2.number
        k = dih.atom3.number
        l = dih.atom4.number
	
        kd = dih.gromacs["param"][0]["kchi"] / kcal2kj
        d = dih.gromacs["param"][0]["delta"]
        n = dih.gromacs["param"][0]["n"]
        print(fmt_dihed % (i, j, k, l, kd, d, n, str(dict_atom_types[i]), str(dict_atom_types[j]), str(dict_atom_types[k]), str(dict_atom_types[l]) ))
        store_num = [str(i), str(j), str(k), str(l)]
        temp = [str(dict_atom_types[i]), str(dict_atom_types[j]), str(dict_atom_types[k]), str(dict_atom_types[l]), kd, n, d]
        #if temp not in dih_list:
        if is_list_present(temp, dih_list):
           ## decide here if it is a fourier series component or just a repetition of dihedrals
           # otherwise the interaction will be counted twice
           if store_num in dih_num:
              dih_list.append(temp)
              dih_list.append('NOTE')
           else:
              pass
        else:
           dih_list.append(temp)
           dih_num.append(store_num)
    return dih_list, dih_num, dihs

def _readimpropers(t,dict_atom_types):
    fmt_dihed_title = "%4s %4s %4s %4s %12s %6s" % ("i", "j", "k", "l", "K_d", "psi0")
    fmt_dihed = "%4s %4s %4s %4s %12.4f %6.2f ; %4s %4s %4s %4s"
    imps = t.molecules[0].impropers
    print("Impropers")
    print("---------")
    print(fmt_dihed_title)
    imp_list = ["IMPROPER"]

    psiphase =False
    for imp in imps:

        # Get atoms
        i = imp.atom1.number
        j = imp.atom2.number
        k = imp.atom3.number
        l = imp.atom4.number

        kd = (imp.gromacs["param"][0]["kpsi"])/(2*kcal2kj)
        psi0 = imp.gromacs["param"][0]["psi0"]
        if psi0 == 180.0:
            psiphase = True
        elif psi0 < 0.0:
            psiphase = True

        print(fmt_dihed % (i, j, k, l, kd, psi0, str(dict_atom_types[i]), str(dict_atom_types[j]), str(dict_atom_types[k]), str(dict_atom_types[l])))
        temp = [str(dict_atom_types[i]), str(dict_atom_types[j]), str(dict_atom_types[k]), str(dict_atom_types[l]), kd, 0, psi0]
        imp_list.append(temp)
    if psiphase == True:
        print("---------")
        print("""
    WARNING: The phase of some improper dihedrals is 180 deg or a nevative number.
             This phase might not be understood by MD engines other than Gromacs 
             Therefore, this energy contribution of this term might be wrong.
             """)
        print("---------")
    return imp_list, imps

def _readpairs(t,dict_atom_types):
    fmt_pair_title = "%4s %4s %12s %12s" % ("i", "j", "epsilon", "sigma")
    fmt_pair = "%4d %4d %12.4f %12.4f"

    pairs = t.molecules[0].pairs
    print("Pairs")
    print("-----")
    pairs_list = []
    for pair in pairs:

        # Get atoms
        i = pair.atom1.number
        j = pair.atom2.number

        eps = (pair.gromacs["param"]["lje14"]) / kcal2kj
        sig = pair.gromacs["param"]["ljl14"] / 0.17818 # Rmin/2 - factor checked against Parmed
        temp = [str(dict_atom_types[i]), str(dict_atom_types[j]), eps, sig]
        pairs_list.append(temp)
 
    print("NOTE: Pairs section is not used by the converter")
    print("---------")
    if not len(pairs_list) == 0:
        print("""
    WARNING: Joyce scales LJ and electrostatic interactions according to the Pairs list.
             Since the same scaling cannot be specified within the *pot or/and *psf file formats, 
             the energy contributions of LJ and EI might be wrong and would need to be
             adjusted by the user with some kind of exclusion list directly in MD engine used
             """)
        print("---------")
        
    return pairs_list, pairs

def _psfWriter():
    out = open("./generated_charmm.psf", "w")
    out.write('PSF\n')
    out.write('\n')
    out.write('{:>10} {:>8}'.format('1','!NTITLE') + '\n')
    out.write(' '+ t.name +'\n')
    out.write('\n')
    out.write('{:>10} {:>7} '.format(str(len(atms)),'!NATOM') + '\n')


    for j, atm in enumerate(atms, start=1):
        i = atm.atomtype
        q = atm.charge
        symbol = atm.name
        mass = atm.mass
        # this only works for a single residue
        out.write('{:>10} {:>4} {:>14} {:>4} {:>7} {:>9} {:>14} {:>14} {:>12}'.format(str(j),\
                "MOL",str(1),t.name, symbol,i,\
                q,mass,str(0)) + '\n')
        
    out.write('\n')
    out.write('{:>10} {:>7} '.format(str(len(bnds)),'!NBOND') + '\n')
    jj_ = len(bnds) % 4
    kk_ = len(bnds)//4

    #bonds
    for j in range(kk_):
        out.write('{:>10} {:>10} {:>10} {:>10} {:>10} {:>10} {:>10} {:>10}'.format(\
                    bnds[4*j].atom1.number,  bnds[4*j].atom2.number,\
                    bnds[4*j+1].atom1.number,bnds[4*j+1].atom2.number,\
                    bnds[4*j+2].atom1.number,bnds[4*j+2].atom2.number,\
                    bnds[4*j+3].atom1.number,bnds[4*j+3].atom2.number) + '\n')
        
    if jj_ != 0:
        if jj_ == 1:
            out.write('{:>10} {:>10}'.format(bnds[4*kk_].atom1.number,bnds[4*kk_].atom2.number))
        elif jj_ == 2:
            out.write('{:>10} {:>10} {:>10} {:>10}'.format(bnds[4*kk_].atom1.number,bnds[4*kk_].atom2.number,\
                    bnds[4*kk_+1].atom1.number,bnds[4*kk_+1].atom2.number))
        elif jj_ == 3:
            out.write('{:>10} {:>10} {:>10} {:>10} {:>10} {:>10}'.format(\
                        bnds[4*kk_].atom1.number, bnds[4*kk_].atom2.number,\
                        bnds[4*kk_+1].atom1.number,bnds[4*kk_+1].atom2.number,\
                        bnds[4*kk_+2].atom1.number,bnds[4*kk_+2].atom2.number))
        out.write('\n')
    out.write('\n')

    #angles
    out.write('{:>10} {:>8} '.format(str(len(angs)),'!NTHETA') + '\n')
    jj_ = len(angs) % 3
    kk_ = len(angs)//3
    for j in range(kk_):
        out.write('{:>10} {:>10} {:>10} {:>10} {:>10} {:>10} {:>10} {:>10} {:>10}'.format(\
                    angs[3*j].atom1.number,angs[3*j].atom2.number,angs[3*j].atom3.number,\
                    angs[3*j+1].atom1.number,angs[3*j+1].atom2.number,angs[3*j+1].atom3.number,\
                    angs[3*j+2].atom1.number,angs[3*j+2].atom2.number,angs[3*j+2].atom3.number)\
                    + '\n')
    if jj_ != 0:
        if jj_ == 1:
            out.write('{:>10} {:>10} {:>10}'.format(angs[3*kk_].atom1.number,\
                        angs[3*kk_].atom2.number,angs[3*kk_].atom3.number))
        if jj_ == 2:
            out.write('{:>10} {:>10} {:>10} {:>10} {:>10} {:>10}'.format(angs[3*kk_].atom1.number,\
                        angs[3*kk_].atom2.number,angs[3*kk_].atom3.number,\
                        angs[3*kk_+1].atom1.number,angs[3*kk_+1].atom2.number,angs[3*kk_+1].atom3.number))
        out.write('\n')
    out.write('\n')

    # Dihedrals
    # all this is done to take care of furier series that must not be repeated in the psf (otherwise they 
    # are counted multiple times)
    reduced_list = []
    for i in range(len(dihs)):
        list = [dihs[i].atom1.number,dihs[i].atom2.number,dihs[i].atom3.number,dihs[i].atom4.number]
        if list not in reduced_list:
            reduced_list.append(list)

    out.write('{:>10} {:>6} '.format(str(len(reduced_list)),'!NPHI') + '\n')
    jj_ = len(reduced_list) % 2
    kk_ = len(reduced_list)//2
    for j in range(kk_):
        out.write('{:>10} {:>10} {:>10} {:>10} {:>10} {:>10} {:>10} {:>10} '.format(\
                    reduced_list[2*j][0] ,reduced_list[2*j][1],reduced_list[2*j][2],reduced_list[2*j][3],\
                    reduced_list[2*j+1][0],reduced_list[2*j+1][1],reduced_list[2*j+1][2],\
                    reduced_list[2*j+1][3])+ '\n')
    if jj_ != 0:
        out.write('{:>10} {:>10} {:>10} {:>10}'.format(reduced_list[2*kk_][0],\
                    reduced_list[2*kk_][1],reduced_list[2*kk_][2],reduced_list[2*kk_][3]))
        out.write('\n')
    out.write('\n')

    #out.write('{:>10} {:>6} '.format(str(len(dihs)),'!NPHI') + '\n')
    #jj_ = len(dihs) % 2
    #kk_ = len(dihs)//2
    #for j in range(kk_):
    #    out.write('{:>10} {:>10} {:>10} {:>10} {:>10} {:>10} {:>10} {:>10} '.format(\
    #                dihs[2*j].atom1.number,dihs[2*j].atom2.number,dihs[2*j].atom3.number,dihs[2*j].atom4.number,\
    #                dihs[2*j+1].atom1.number,dihs[2*j+1].atom2.number,dihs[2*j+1].atom3.number,\
    #                dihs[2*j+1].atom4.number)+ '\n')
    #if jj_ != 0:
    #    out.write('{:>10} {:>10} {:>10} {:>10}'.format(dihs[2*kk_].atom1.number,\
    #                dihs[2*kk_].atom2.number,dihs[2*kk_].atom3.number,dihs[2*kk_].atom4.number))
    #    out.write('\n')
    #out.write('\n')

    #Impropers
    out.write('{:>10} {:>8} '.format(str(len(imps)),'!NIMPHI') + '\n')
    jj_ = len(imps) % 2
    kk_ = len(imps)//2
    for j in range(kk_):
        out.write('{:>10} {:>10} {:>10} {:>10} {:>10} {:>10} {:>10} {:>10} '.format(\
                    imps[2*j].atom1.number,imps[2*j].atom2.number,imps[2*j].atom3.number,imps[2*j].atom4.number,\
                    imps[2*j+1].atom1.number,imps[2*j+1].atom2.number,imps[2*j+1].atom3.number,imps[2*j+1].atom4.number)\
                    + '\n')
    if jj_ != 0:
        out.write('{:>10} {:>10} {:>10} {:>10}'.format(imps[2*kk_].atom1.number,\
                    imps[2*kk_].atom2.number,imps[2*kk_].atom3.number,imps[2*kk_].atom4.number))
        out.write('\n')
    out.write('\n')
    out.write('{:>10} '.format(str(0)) + ' !NDON' + '\n')
    out.write('\n')
    out.write('{:>10} '.format(str(0)) + ' !NACC' + '\n')
    out.write('\n')
    out.write('{:>10} '.format(str(0)) + ' !NNB' + '\n')
    out.write('\n')
    out.write('{:>10} '.format(str(0)) + ' !NGRP' + '\n')
    out.write('\n')


if __name__ == '__main__':
    parser = arg.ArgumentParser(description="Gro2Charmm Converter Program")
    parser.add_argument('--version','-V',action='version',version=PROGVERS,
                     help="Show program's full version number, and exit")
    parser.add_argument('topofile',help='topology.top as it comes out of Joyce program')
    args = parser.parse_args()

    datafile = args.topofile
    t = TOP(datafile)
    
    # Atoms
    dict_atom_types, lj_list, atms = _readatoms(t)

    # Bonds
    bnd_list, bnds = _readbonds(t,dict_atom_types)

    # Angles
    ang_list, angs = _readangles(t,dict_atom_types)

    # Dihedrals
    dih_list, dih_num, dihs = _readdihed(t,dict_atom_types)

    # Impropers 
    imp_list, imps = _readimpropers(t,dict_atom_types)

    # Pairs
    pairs_list, pairs = _readpairs(t,dict_atom_types)

    #####################################################
    ###############   generate pot  #####################
    #####################################################
    out = open("generated_charmm.pot", "w")
    for temp_list in [bnd_list, ang_list, dih_list, imp_list, lj_list]:
        out.write(temp_list[0] + "\n")
        for sublist in temp_list[1:]:
           if sublist == "NOTE":
              out.write("WARNING: the MD code might not understand multiple series with same atomtypes" + "\n")
           else:
              line = "     ".join(str(item) for item in sublist)  
              out.write(line + "\n") 
    out.write("END")
    out.close()
    print("Generated FF file in Charmm format")
    print("---------")

    #####################################################
    ###############   generate psf  #####################
    #####################################################
    _psfWriter()
    print("Generated psf file in CHARMM (unformatted) format")
    print("---------")


